/* tslint:disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v12.0.4.0 (NJsonSchema v9.12.7.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

export class BaseClient {
    protected transformOptions(options: RequestInit) {
        const token = window.localStorage.getItem('Token');
        let headers = new Headers(options.headers);
        headers.append("Authorization", "Bearer " + token); 
        options.headers = headers;
        return Promise.resolve(options);
    }
}

export class ArticleClient extends BaseClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "http://localhost:56833";
    }

    addArticle(model: ArticleModel): Promise<ResultModelOfString> {
        let url_ = this.baseUrl + "/api/Article/AddArticle";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processAddArticle(_response);
        });
    }

    protected processAddArticle(response: Response): Promise<ResultModelOfString> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ResultModelOfString.fromJS(resultData200) : new ResultModelOfString();
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ResultModelOfString>(<any>null);
    }

    delArticle(id: string | null | undefined): Promise<ResultModel> {
        let url_ = this.baseUrl + "/api/Article/DelArticle?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDelArticle(_response);
        });
    }

    protected processDelArticle(response: Response): Promise<ResultModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ResultModel.fromJS(resultData200) : new ResultModel();
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ResultModel>(<any>null);
    }

    updateArticle(model: ArticleModel): Promise<ResultModel> {
        let url_ = this.baseUrl + "/api/Article/UpdateArticle";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdateArticle(_response);
        });
    }

    protected processUpdateArticle(response: Response): Promise<ResultModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ResultModel.fromJS(resultData200) : new ResultModel();
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ResultModel>(<any>null);
    }

    getArticle(id: string | null | undefined): Promise<ResultModelOfArticleModel> {
        let url_ = this.baseUrl + "/api/Article/GetArticle?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetArticle(_response);
        });
    }

    protected processGetArticle(response: Response): Promise<ResultModelOfArticleModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ResultModelOfArticleModel.fromJS(resultData200) : new ResultModelOfArticleModel();
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ResultModelOfArticleModel>(<any>null);
    }

    getArticles(model: SearchArticleModel): Promise<ResultModelOfListOfArticleListModel> {
        let url_ = this.baseUrl + "/api/Article/GetArticles";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetArticles(_response);
        });
    }

    protected processGetArticles(response: Response): Promise<ResultModelOfListOfArticleListModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ResultModelOfListOfArticleListModel.fromJS(resultData200) : new ResultModelOfListOfArticleListModel();
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ResultModelOfListOfArticleListModel>(<any>null);
    }

    addChannel(model: ChannelModel): Promise<ResultModelOfString> {
        let url_ = this.baseUrl + "/api/Article/AddChannel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processAddChannel(_response);
        });
    }

    protected processAddChannel(response: Response): Promise<ResultModelOfString> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ResultModelOfString.fromJS(resultData200) : new ResultModelOfString();
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ResultModelOfString>(<any>null);
    }

    getChannelsToCascader(channelId: string | null | undefined): Promise<Cascader[]> {
        let url_ = this.baseUrl + "/api/Article/GetChannelsToCascader?";
        if (channelId !== undefined)
            url_ += "channelId=" + encodeURIComponent("" + channelId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetChannelsToCascader(_response);
        });
    }

    protected processGetChannelsToCascader(response: Response): Promise<Cascader[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Cascader.fromJS(item));
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Cascader[]>(<any>null);
    }
}

export class AuthClient extends BaseClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "http://localhost:56833";
    }

    signIn(name: string | null | undefined, pwd: string | null | undefined): Promise<AuthModel> {
        let url_ = this.baseUrl + "/api/Auth?";
        if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        if (pwd !== undefined)
            url_ += "pwd=" + encodeURIComponent("" + pwd) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSignIn(_response);
        });
    }

    protected processSignIn(response: Response): Promise<AuthModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AuthModel.fromJS(resultData200) : new AuthModel();
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AuthModel>(<any>null);
    }
}

export class FileClient extends BaseClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "http://localhost:56833";
    }

    uploadImg(file: FileParameter | null | undefined): Promise<ResultModelOfFileModel> {
        let url_ = this.baseUrl + "/api/File/UploadImg";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file !== null && file !== undefined)
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUploadImg(_response);
        });
    }

    protected processUploadImg(response: Response): Promise<ResultModelOfFileModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ResultModelOfFileModel.fromJS(resultData200) : new ResultModelOfFileModel();
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ResultModelOfFileModel>(<any>null);
    }

    delImg(id: string | null | undefined, ownerId: string | null | undefined): Promise<ResultModel> {
        let url_ = this.baseUrl + "/api/File/DelImg?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        if (ownerId !== undefined)
            url_ += "ownerId=" + encodeURIComponent("" + ownerId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDelImg(_response);
        });
    }

    protected processDelImg(response: Response): Promise<ResultModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ResultModel.fromJS(resultData200) : new ResultModel();
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ResultModel>(<any>null);
    }
}

export class UserClient extends BaseClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "http://localhost:56833";
    }

    get(): Promise<UserModel[] | null> {
        let url_ = this.baseUrl + "/api/User";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<UserModel[] | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(UserModel.fromJS(item));
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserModel[] | null>(<any>null);
    }
}

export class ResultModel implements IResultModel {
    status?: boolean | undefined;
    message?: string | undefined;

    constructor(data?: IResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.status = data["status"];
            this.message = data["message"];
        }
    }

    static fromJS(data: any): ResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new ResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["message"] = this.message;
        return data; 
    }
}

export interface IResultModel {
    status?: boolean | undefined;
    message?: string | undefined;
}

export class ResultModelOfString extends ResultModel implements IResultModelOfString {
    data?: string | undefined;
    total?: number | undefined;

    constructor(data?: IResultModelOfString) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.data = data["data"];
            this.total = data["total"];
        }
    }

    static fromJS(data: any): ResultModelOfString {
        data = typeof data === 'object' ? data : {};
        let result = new ResultModelOfString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data;
        data["total"] = this.total;
        super.toJSON(data);
        return data; 
    }
}

export interface IResultModelOfString extends IResultModel {
    data?: string | undefined;
    total?: number | undefined;
}

export class ArticleModel implements IArticleModel {
    id?: string | undefined;
    title?: string | undefined;
    subTitle?: string | undefined;
    summary?: string | undefined;
    userId?: string | undefined;
    ownerId?: string | undefined;
    channelId?: string[] | undefined;
    channelName?: string | undefined;
    author?: string | undefined;
    editor!: number;
    content?: string | undefined;
    mdContent?: string | undefined;
    viewed!: number;
    created!: Date;
    updated!: Date;
    state?: number | undefined;
    files?: string[] | undefined;

    constructor(data?: IArticleModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.title = data["title"];
            this.subTitle = data["subTitle"];
            this.summary = data["summary"];
            this.userId = data["userId"];
            this.ownerId = data["ownerId"];
            if (data["channelId"] && data["channelId"].constructor === Array) {
                this.channelId = [];
                for (let item of data["channelId"])
                    this.channelId.push(item);
            }
            this.channelName = data["channelName"];
            this.author = data["author"];
            this.editor = data["editor"];
            this.content = data["content"];
            this.mdContent = data["mdContent"];
            this.viewed = data["viewed"];
            this.created = data["created"] ? new Date(data["created"].toString()) : <any>undefined;
            this.updated = data["updated"] ? new Date(data["updated"].toString()) : <any>undefined;
            this.state = data["state"];
            if (data["files"] && data["files"].constructor === Array) {
                this.files = [];
                for (let item of data["files"])
                    this.files.push(item);
            }
        }
    }

    static fromJS(data: any): ArticleModel {
        data = typeof data === 'object' ? data : {};
        let result = new ArticleModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["subTitle"] = this.subTitle;
        data["summary"] = this.summary;
        data["userId"] = this.userId;
        data["ownerId"] = this.ownerId;
        if (this.channelId && this.channelId.constructor === Array) {
            data["channelId"] = [];
            for (let item of this.channelId)
                data["channelId"].push(item);
        }
        data["channelName"] = this.channelName;
        data["author"] = this.author;
        data["editor"] = this.editor;
        data["content"] = this.content;
        data["mdContent"] = this.mdContent;
        data["viewed"] = this.viewed;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["updated"] = this.updated ? this.updated.toISOString() : <any>undefined;
        data["state"] = this.state;
        if (this.files && this.files.constructor === Array) {
            data["files"] = [];
            for (let item of this.files)
                data["files"].push(item);
        }
        return data; 
    }
}

export interface IArticleModel {
    id?: string | undefined;
    title?: string | undefined;
    subTitle?: string | undefined;
    summary?: string | undefined;
    userId?: string | undefined;
    ownerId?: string | undefined;
    channelId?: string[] | undefined;
    channelName?: string | undefined;
    author?: string | undefined;
    editor: number;
    content?: string | undefined;
    mdContent?: string | undefined;
    viewed: number;
    created: Date;
    updated: Date;
    state?: number | undefined;
    files?: string[] | undefined;
}

export class ResultModelOfArticleModel extends ResultModel implements IResultModelOfArticleModel {
    data?: ArticleModel | undefined;
    total?: number | undefined;

    constructor(data?: IResultModelOfArticleModel) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.data = data["data"] ? ArticleModel.fromJS(data["data"]) : <any>undefined;
            this.total = data["total"];
        }
    }

    static fromJS(data: any): ResultModelOfArticleModel {
        data = typeof data === 'object' ? data : {};
        let result = new ResultModelOfArticleModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["total"] = this.total;
        super.toJSON(data);
        return data; 
    }
}

export interface IResultModelOfArticleModel extends IResultModel {
    data?: ArticleModel | undefined;
    total?: number | undefined;
}

export class ResultModelOfListOfArticleListModel extends ResultModel implements IResultModelOfListOfArticleListModel {
    data?: ArticleListModel[] | undefined;
    total?: number | undefined;

    constructor(data?: IResultModelOfListOfArticleListModel) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            if (data["data"] && data["data"].constructor === Array) {
                this.data = [];
                for (let item of data["data"])
                    this.data.push(ArticleListModel.fromJS(item));
            }
            this.total = data["total"];
        }
    }

    static fromJS(data: any): ResultModelOfListOfArticleListModel {
        data = typeof data === 'object' ? data : {};
        let result = new ResultModelOfListOfArticleListModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.data && this.data.constructor === Array) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["total"] = this.total;
        super.toJSON(data);
        return data; 
    }
}

export interface IResultModelOfListOfArticleListModel extends IResultModel {
    data?: ArticleListModel[] | undefined;
    total?: number | undefined;
}

export class ArticleListModel implements IArticleListModel {
    id?: string | undefined;
    title?: string | undefined;
    userName?: string | undefined;
    channelId?: string | undefined;
    channelName?: string | undefined;
    subTitle?: string | undefined;
    summary?: string | undefined;
    viewed!: number;
    author?: string | undefined;
    created!: Date;
    updated!: Date;
    state!: number;

    constructor(data?: IArticleListModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.title = data["title"];
            this.userName = data["userName"];
            this.channelId = data["channelId"];
            this.channelName = data["channelName"];
            this.subTitle = data["subTitle"];
            this.summary = data["summary"];
            this.viewed = data["viewed"];
            this.author = data["author"];
            this.created = data["created"] ? new Date(data["created"].toString()) : <any>undefined;
            this.updated = data["updated"] ? new Date(data["updated"].toString()) : <any>undefined;
            this.state = data["state"];
        }
    }

    static fromJS(data: any): ArticleListModel {
        data = typeof data === 'object' ? data : {};
        let result = new ArticleListModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["userName"] = this.userName;
        data["channelId"] = this.channelId;
        data["channelName"] = this.channelName;
        data["subTitle"] = this.subTitle;
        data["summary"] = this.summary;
        data["viewed"] = this.viewed;
        data["author"] = this.author;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["updated"] = this.updated ? this.updated.toISOString() : <any>undefined;
        data["state"] = this.state;
        return data; 
    }
}

export interface IArticleListModel {
    id?: string | undefined;
    title?: string | undefined;
    userName?: string | undefined;
    channelId?: string | undefined;
    channelName?: string | undefined;
    subTitle?: string | undefined;
    summary?: string | undefined;
    viewed: number;
    author?: string | undefined;
    created: Date;
    updated: Date;
    state: number;
}

export class Query implements IQuery {
    take!: number;
    skip!: number;
    sort?: Sort[] | undefined;
    filter?: Filter[] | undefined;

    constructor(data?: IQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.take = data["take"];
            this.skip = data["skip"];
            if (data["sort"] && data["sort"].constructor === Array) {
                this.sort = [];
                for (let item of data["sort"])
                    this.sort.push(Sort.fromJS(item));
            }
            if (data["filter"] && data["filter"].constructor === Array) {
                this.filter = [];
                for (let item of data["filter"])
                    this.filter.push(Filter.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Query {
        data = typeof data === 'object' ? data : {};
        let result = new Query();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["take"] = this.take;
        data["skip"] = this.skip;
        if (this.sort && this.sort.constructor === Array) {
            data["sort"] = [];
            for (let item of this.sort)
                data["sort"].push(item.toJSON());
        }
        if (this.filter && this.filter.constructor === Array) {
            data["filter"] = [];
            for (let item of this.filter)
                data["filter"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IQuery {
    take: number;
    skip: number;
    sort?: Sort[] | undefined;
    filter?: Filter[] | undefined;
}

export class SearchArticleModel extends Query implements ISearchArticleModel {
    id?: string | undefined;
    title?: string | undefined;
    userName?: string | undefined;
    createdDate?: string | undefined;

    constructor(data?: ISearchArticleModel) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.id = data["id"];
            this.title = data["title"];
            this.userName = data["userName"];
            this.createdDate = data["createdDate"];
        }
    }

    static fromJS(data: any): SearchArticleModel {
        data = typeof data === 'object' ? data : {};
        let result = new SearchArticleModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["userName"] = this.userName;
        data["createdDate"] = this.createdDate;
        super.toJSON(data);
        return data; 
    }
}

export interface ISearchArticleModel extends IQuery {
    id?: string | undefined;
    title?: string | undefined;
    userName?: string | undefined;
    createdDate?: string | undefined;
}

export class Sort implements ISort {
    field?: string | undefined;
    desc!: boolean;

    constructor(data?: ISort) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.field = data["field"];
            this.desc = data["desc"];
        }
    }

    static fromJS(data: any): Sort {
        data = typeof data === 'object' ? data : {};
        let result = new Sort();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["field"] = this.field;
        data["desc"] = this.desc;
        return data; 
    }
}

export interface ISort {
    field?: string | undefined;
    desc: boolean;
}

export class Filter implements IFilter {
    field?: string | undefined;
    value?: any | undefined;

    constructor(data?: IFilter) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.field = data["field"];
            this.value = data["value"];
        }
    }

    static fromJS(data: any): Filter {
        data = typeof data === 'object' ? data : {};
        let result = new Filter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["field"] = this.field;
        data["value"] = this.value;
        return data; 
    }
}

export interface IFilter {
    field?: string | undefined;
    value?: any | undefined;
}

export class ChannelModel implements IChannelModel {
    id?: string | undefined;
    parentId?: string | undefined;
    title?: string | undefined;
    description?: string | undefined;
    state!: number;

    constructor(data?: IChannelModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.parentId = data["parentId"];
            this.title = data["title"];
            this.description = data["description"];
            this.state = data["state"];
        }
    }

    static fromJS(data: any): ChannelModel {
        data = typeof data === 'object' ? data : {};
        let result = new ChannelModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["parentId"] = this.parentId;
        data["title"] = this.title;
        data["description"] = this.description;
        data["state"] = this.state;
        return data; 
    }
}

export interface IChannelModel {
    id?: string | undefined;
    parentId?: string | undefined;
    title?: string | undefined;
    description?: string | undefined;
    state: number;
}

export class Cascader implements ICascader {
    value?: string | undefined;
    label?: string | undefined;
    children?: Cascader[] | undefined;
    loading?: boolean | undefined;

    constructor(data?: ICascader) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.value = data["value"];
            this.label = data["label"];
            if (data["children"] && data["children"].constructor === Array) {
                this.children = [];
                for (let item of data["children"])
                    this.children.push(Cascader.fromJS(item));
            }
            this.loading = data["loading"];
        }
    }

    static fromJS(data: any): Cascader {
        data = typeof data === 'object' ? data : {};
        let result = new Cascader();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["label"] = this.label;
        if (this.children && this.children.constructor === Array) {
            data["children"] = [];
            for (let item of this.children)
                data["children"].push(item.toJSON());
        }
        data["loading"] = this.loading;
        return data; 
    }
}

export interface ICascader {
    value?: string | undefined;
    label?: string | undefined;
    children?: Cascader[] | undefined;
    loading?: boolean | undefined;
}

export class AuthModel implements IAuthModel {
    userName?: string | undefined;
    token?: string | undefined;
    tokenType?: string | undefined;
    status?: string | undefined;

    constructor(data?: IAuthModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userName = data["userName"];
            this.token = data["token"];
            this.tokenType = data["tokenType"];
            this.status = data["status"];
        }
    }

    static fromJS(data: any): AuthModel {
        data = typeof data === 'object' ? data : {};
        let result = new AuthModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["token"] = this.token;
        data["tokenType"] = this.tokenType;
        data["status"] = this.status;
        return data; 
    }
}

export interface IAuthModel {
    userName?: string | undefined;
    token?: string | undefined;
    tokenType?: string | undefined;
    status?: string | undefined;
}

export class ResultModelOfFileModel extends ResultModel implements IResultModelOfFileModel {
    data?: FileModel | undefined;
    total?: number | undefined;

    constructor(data?: IResultModelOfFileModel) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.data = data["data"] ? FileModel.fromJS(data["data"]) : <any>undefined;
            this.total = data["total"];
        }
    }

    static fromJS(data: any): ResultModelOfFileModel {
        data = typeof data === 'object' ? data : {};
        let result = new ResultModelOfFileModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["total"] = this.total;
        super.toJSON(data);
        return data; 
    }
}

export interface IResultModelOfFileModel extends IResultModel {
    data?: FileModel | undefined;
    total?: number | undefined;
}

export class FileModel implements IFileModel {
    id?: string | undefined;
    ownerId?: string | undefined;
    name?: string | undefined;
    path?: string | undefined;
    md5?: string | undefined;

    constructor(data?: IFileModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.ownerId = data["ownerId"];
            this.name = data["name"];
            this.path = data["path"];
            this.md5 = data["md5"];
        }
    }

    static fromJS(data: any): FileModel {
        data = typeof data === 'object' ? data : {};
        let result = new FileModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["ownerId"] = this.ownerId;
        data["name"] = this.name;
        data["path"] = this.path;
        data["md5"] = this.md5;
        return data; 
    }
}

export interface IFileModel {
    id?: string | undefined;
    ownerId?: string | undefined;
    name?: string | undefined;
    path?: string | undefined;
    md5?: string | undefined;
}

export class UserModel implements IUserModel {
    id?: string | undefined;
    userName?: string | undefined;

    constructor(data?: IUserModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.userName = data["userName"];
        }
    }

    static fromJS(data: any): UserModel {
        data = typeof data === 'object' ? data : {};
        let result = new UserModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userName"] = this.userName;
        return data; 
    }
}

export interface IUserModel {
    id?: string | undefined;
    userName?: string | undefined;
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export class SwaggerException extends Error {
    message: string;
    status: number; 
    response: string; 
    headers: { [key: string]: any; };
    result: any; 

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if(result !== null && result !== undefined)
        throw result;
    else
        throw new SwaggerException(message, status, response, headers, null);
}

/* tslint:disable */

export class Result<T>{
    data?: T
    total?: number
}